import java.lang.reflect.Modifier

/*
 * Copyright (c) 2013, Francis Galiegue <fgaliegue@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Lesser GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Lesser GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This has to be here... It will not be taken into account in common.gradle!
 *
 * Looks like a serious bug... See also:
 *
 * http://forums.gradle.org/gradle/topics/buildscript_in_subprojects_ignored
 */
buildscript {
    repositories {
        mavenCentral();
    }
    dependencies {
        classpath(group: "eu.appsatori", name: "gradle-fatjar-plugin",
            version: "0.2-rc2");
    }
};

apply(plugin: "java");
apply(plugin: "maven");
apply(plugin: "signing");
apply(plugin: "osgi");
apply(plugin: "fatjar");

apply(from: "project.gradle");

/*
 * Repositories to use
 */
repositories {
    mavenCentral();
}

/*
 * Necessary! Otherwise TestNG will not be used...
 *
 * Also, we don't want gradle's default HTML report: it does not support
 * parameterized tests which I use a _lot_.
 */
test {
    useTestNG() {
        useDefaultListeners = true;
    };
    testReport = false;
}

/*
 * Necessary to generate the source and javadoc jars
 */
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = "sources";
    from sourceSets.main.allSource;
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = "javadoc";
    from javadoc.destinationDir;
}

fatJar {
    classifier = "full";
}

artifacts {
    archives jar;
    archives sourcesJar;
    archives javadocJar;
// bad idea:    archives fatJar;
}

task wrapper(type: Wrapper) {
    gradleVersion = "1.6";
}

task pom << {
    pom {}.writeTo("${projectDir}/pom.xml");
}

project.ext {
    dotClass = ".class";
    classpathURI = sourceSets.main.output.classesDir.canonicalFile.toURI();
    serviceMap = new HashMap<Class<?>, List<String>>();
    tree = fileTree(classpathURI.path)
        .filter({ it.isFile() && it.name.endsWith(dotClass); }); // FileTree
    resourceURI = sourceSets.main.output.resourcesDir.canonicalFile.toURI()
        .resolve("META-INF/services/"); // Ending '/' is critical!
}

task generateServiceFiles(dependsOn: compileJava) << {
    if (!project.hasProperty("serviceClasses"))
        return;
    if (serviceClasses.empty)
        return;
    project.ext({
        runtimeURLs = sourceSets.main.runtimeClasspath.collect({
            it.toURI().toURL()
        }) as URL[];
        classLoader = URLClassLoader.newInstance(runtimeURLs);
    });
    serviceClasses.each() {
        serviceMap.put(classLoader.loadClass(it), new ArrayList<String>());
    };
    tree.each() {
        File candidate ->
            serviceMap.each() {
                key, value ->
                    final String className = toClassName(candidate);
                    if (isImplementationOf(key, className))
                        value.add(className);
            }
    };
    createServicesDirectory();
    serviceMap.each() {
        name, list ->
            if (list.empty)
                return;
            final String path = resourceURI.resolve(name.canonicalName)
                .getPath();
            new File(path).withWriter {
                out -> list.each() { out.writeLine(it); }
            };
    };
}

processResources {
    dependsOn(generateServiceFiles);
}


/*
 * We have to redefine these for compatibility with IDEA: unfortunately it
 * cannot include separate directories for classes and resources...
 */
project.ext {
    ideaPath = new File("out").canonicalFile;
    ideaProd = new File("out/production/${name}").canonicalFile;
    ideaTest = new File("out/test/${name}").canonicalFile;
}

/*
 * We have to do that, otherwise IDEA won't see the generated service files
 */
task prepareIdea(dependsOn: testClasses) << {
    if (ideaPath.exists())
        delete(ideaPath);
    ideaProd.mkdirs();
    ideaTest.mkdirs();
    copy {
        from(sourceSets.main.output.classesDir);
        from(sourceSets.main.output.resourcesDir);
        into(ideaProd);
    };
    copy {
        from(sourceSets.test.output.classesDir);
        from(sourceSets.test.output.resourcesDir);
        into(ideaTest);
    };
}

/*
 * Support methods for the generateServiceFiles task
 */

void createServicesDirectory()
{
    final File file = new File(resourceURI.getPath());
    if (file.exists()) {
        if (!file.directory)
            throw new IOException("file " + file + " exists but is not a directory");
        return;
    }
    if (!file.mkdirs())
        throw new IOException("failed to create META-INF/services directory");
}

String toClassName(final File file)
{
    final URI uri = file.canonicalFile.toURI();
    final String path = classpathURI.relativize(uri).getPath();
    return path.substring(0, path.length() - dotClass.length())
        .replace("/", ".");
}

boolean isImplementationOf(final Class<?> baseClass, final String className)
{
    final Class<?> c = classLoader.loadClass(className);
    final int modifiers = c.modifiers;
    if (c.anonymousClass)
        return false;
    if (c.interface)
        return false;
    if (c.enum)
        return false;
    if (Modifier.isAbstract(modifiers))
        return false;
    return Modifier.isPublic(modifiers) && baseClass.isAssignableFrom(c);
}

/*
 * SIGNING
 */

project.ext {
    gitrwscm = sprintf("git@github.com:fge/%s", name);
    gitroscm = sprintf("https://github.com/fge/%s.git", name);
    projectURL = sprintf("https://github.com/fge/%s", name);
    sonatypeStaging = "https://oss.sonatype.org/service/local/staging/deploy/maven2/";
    sonatypeSnapshots = "https://oss.sonatype.org/content/repositories/snapshots/";
};

task checkSigningRequirements << {
    def requiredProperties = [ "sonatypeUsername", "sonatypePassword" ];
    def noDice = false;
    requiredProperties.each {
        if (!project.hasProperty(it)) {
            noDice = true;
            System.err.printf("property \"%s\" is not defined!")
        }
    }
    if (noDice)
        throw new IllegalStateException("missing required properties for " +
            "upload");
}

uploadArchives {
    dependsOn(checkSigningRequirements);
    repositories {
        mavenDeployer {
            beforeDeployment {
                MavenDeployment deployment -> signing.signPom(deployment);
            }

            repository(url: "${sonatypeStaging}") {
                authentication(userName: sonatypeUsername,
                    password: sonatypePassword);
            }

            snapshotRepository(url: "${sonatypeSnapshots}") {
                authentication(userName: sonatypeUsername,
                    password: sonatypePassword);
            }
        }
    }
}

/*
 * Configure pom.xml on install, uploadArchives
 */
[
    install.repositories.mavenInstaller,
    uploadArchives.repositories.mavenDeployer
]*.pom*.whenConfigured { pom ->
    pom.project {
        name "${name}";
        packaging "jar";
        description "${description}";
        url "${projectURL}";

        scm {
            url "${gitrwscm}";
            connection "${gitrwscm}";
            developerConnection "${gitroscm}";
        }

        licenses {
            license {
                name "Lesser General Public License, version 3 or greater";
                url "http://www.gnu.org/licenses/lgpl.html";
                distribution "repo";
            }
        }

        developers {
            developer {
                id "fge";
                name "Francis Galiegue";
                email "fgaliegue@gmail.com";
            }
        }
    }
}

ext.forRelease = !version.endsWith("-SNAPSHOT");
signing {
    required { forRelease && gradle.taskGraph.hasTask("uploadArchives") };
    sign configurations.archives;
}

